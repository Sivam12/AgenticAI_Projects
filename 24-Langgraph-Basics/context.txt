Here is the context of the source tree and the files:
Store the context. Based on the context, I will be asking questions later.
# Source Tree
.
├── 01-iseven.py
├── 02-iseven.py
├── 03-lg-single-node-iseven.py
├── 04-lg-two-nodes.py
├── 05-lg-three-nodes.py
├── 06-lg-if-else-branching.py
├── context.txt
├── lg_utility.py


# 01-iseven.py
from langgraph.graph import StateGraph, START, END
from lg_utility import save_graph_as_png
from typing import TypedDict

class State(TypedDict):
    value: int

def is_even(state: State):
    print(state["value"])
    if state["value"] % 2 == 0:
        tstr = f"{state['value']} is Even number"
    else:
        tstr = f"{state['value']} is Odd number"
        
    print(tstr)
    return state

def build_graph():
    builder = StateGraph(State)
    
    builder.add_node("EVEN_ODD", is_even)

    builder.add_edge(START, "EVEN_ODD")
    builder.add_edge("EVEN_ODD", END)

    graph = builder.compile()

    save_graph_as_png(graph, __file__)

    return graph


graph = build_graph()
    

def main():
    response = graph.invoke({"value": 10})
    print(f"Response :{response}")
    print()
    
if __name__ == "__main__":
    main()



# 02-iseven.py
from langgraph.graph import StateGraph, START, END
from lg_utility import save_graph_as_png
from typing import TypedDict

class State(TypedDict):
    value: int
    output: str

def is_even(state: State):
    if state["value"] % 2 == 0:
        tstr = f"{state['value']} is Even number"
    else:
        tstr = f"{state['value']} is Odd number"
        
    state["output"] = tstr
    return state

def build_graph():
    builder = StateGraph(State)
    
    builder.add_node("EVEN_ODD", is_even)

    builder.add_edge(START, "EVEN_ODD")
    builder.add_edge("EVEN_ODD", END)

    graph = builder.compile()

    save_graph_as_png(graph, __file__)

    return graph


graph = build_graph()
    

def main():
    response = graph.invoke({"value": 10})
    print(f"Response :{response}")
    print(f"Output   :{response['output']}")
    print()
    
if __name__ == "__main__":
    main()



# 03-lg-single-node-iseven.py
from langgraph.graph import StateGraph, START, END
from lg_utility import save_graph_as_png
from typing import TypedDict

class State(TypedDict):
    value: int
    is_even: bool
    output: str

def initialize_state_defaults(state: dict):
    return {
        "value": state.get("value", 0),
        "is_even": False,
        "output": None
    }

def is_even(state: State):
    if state["value"] % 2 == 0:
        state["is_even"] = True
    else:
        state["is_even"] = False
        
    return state

def build_output(state: State):
    if state['is_even']:
        tstr = f"{state['value']} is Even number"
    else:
        tstr = f"{state['value']} is Odd number"
        
    state["output"] = tstr
    return state

def build_graph():
    builder = StateGraph(State)
    
    builder.add_node("INITIALIZER", initialize_state_defaults)
    builder.add_node("EVEN_ODD", is_even)
    builder.add_node("OUTPUT", build_output)

    builder.add_edge(START, "INITIALIZER")
    builder.add_edge("INITIALIZER", "EVEN_ODD")
    builder.add_edge("EVEN_ODD", "OUTPUT")
    builder.add_edge("OUTPUT", END)

    graph = builder.compile()

    save_graph_as_png(graph, __file__)

    return graph


graph = build_graph()
    

def main():
    response = graph.invoke({"value": 10})
    print(f"Response :{response}")
    print(f"Output   :{response['output']}")
    print()
    
if __name__ == "__main__":
    main()



# 04-lg-two-nodes.py
from langgraph.graph import StateGraph, START, END
from lg_utility import save_graph_as_png
from typing import TypedDict

class State(TypedDict):
    value: int
    is_even: bool
    is_odd: bool
    output: str

def initialize_state_defaults(state: dict):
    return {
        "value": state.get("value", 0),
        "is_even": False,
        "is_odd": False,
        "output": None
    }

def is_even(state: State):
    if state["value"] % 2 == 0:
        state["is_even"] = True
    else:
        state["is_even"] = False
        
    return state

def is_odd(state: State):
    if state["value"] % 2 == 0:
        state["is_odd"] = False
    else:
        state["is_odd"] = True
    
    return state

def build_output(state: State):
    if state['is_even']:
        tstr = f"{state['value']} is Even number"
    else:
        tstr = f"{state['value']} is Odd number"
        
    state["output"] = tstr
    return state
    
def build_graph():
    builder = StateGraph(State)
    
    builder.add_node("INITIALIZER", initialize_state_defaults)
    builder.add_node("EVEN_NUM", is_even)
    builder.add_node("ODD_NUM", is_odd)
    builder.add_node("OUTPUT", build_output)
    
    builder.add_edge(START, "INITIALIZER")
    builder.add_edge("INITIALIZER", "EVEN_NUM")
    builder.add_edge("EVEN_NUM", "ODD_NUM")
    builder.add_edge("ODD_NUM", "OUTPUT")
    builder.add_edge("OUTPUT", END)

    graph = builder.compile()

    save_graph_as_png(graph, __file__)

    return graph


graph = build_graph()
    

def main():
    response = graph.invoke({"value": 10})
    print(f"Response :{response}")
    print(f"output   :{response['output']}")
    print()
    
if __name__ == "__main__":
    main()



# 05-lg-three-nodes.py
from langgraph.graph import StateGraph, START, END
from lg_utility import save_graph_as_png
from typing import TypedDict

def is_n_prime(n):
    if n == 2:
        return True
    
    for i in range(2, n):
        if n%i == 0:
            return False
    
    return True

class State(TypedDict):
    value: int
    is_even: bool
    is_odd: bool
    is_prime: bool
    output: str

def initialize_state_defaults(state: dict):
    return {
        "value": state.get("value", 0),
        "is_even": False,
        "is_odd": False,
        "is_prime": False,
        "output": None
    }

def is_even(state: State):
    if state["value"] % 2 == 0:
        state["is_even"] = True
    else:
        state["is_even"] = False
        
    return state

def is_odd(state: State):
    if state["value"] % 2 == 0:
        state["is_odd"] = False
    else:
        state["is_even"] = True
    
    return state

def is_prime(state: State):
    n = state["value"]
    state["is_prime"] = is_n_prime(n)

    return state

def build_output(state: State):
    if state['is_even']:
        tstr = f"{state['value']} is Even number"
    else:
        tstr = f"{state['value']} is Odd number"

    if state["is_prime"]:
        tstr += " and Prime"
    else:
        tstr += " and Not a Prime"
        
    state["output"] = tstr
    return state

   
def build_graph():
    builder = StateGraph(State)
    
    builder.add_node("INITIALIZER", initialize_state_defaults)
    builder.add_node("EVEN_NUM", is_even)
    builder.add_node("ODD_NUM", is_odd)
    builder.add_node("PRIME_NUM", is_prime)
    builder.add_node("OUTPUT", build_output)
    
    builder.add_edge(START, "INITIALIZER")
    builder.add_edge("INITIALIZER", "EVEN_NUM")
    builder.add_edge("EVEN_NUM", "ODD_NUM")
    builder.add_edge("ODD_NUM", "PRIME_NUM")
    builder.add_edge("PRIME_NUM", "OUTPUT")
    builder.add_edge("OUTPUT", END)

    graph = builder.compile()

    save_graph_as_png(graph, __file__)

    return graph


graph = build_graph()
    

def main():
    response = graph.invoke({"value": 10})
    print(f"Response :{response}")
    print(f"output   :{response['output']}")
    print()
    
if __name__ == "__main__":
    main()



# 06-lg-if-else-branching.py
from langgraph.graph import StateGraph, START, END
from lg_utility import save_graph_as_png
from typing import TypedDict

def is_n_prime(n):
    if n == 2:
        return True
    
    for i in range(2, n):
        if n%i == 0:
            return False
    
    return True

class State(TypedDict):
    value: int
    is_even: bool
    is_odd: bool
    is_prime: bool
    route: str
    output: str

def initialize_state_defaults(state: dict):
    return {
        "value": state.get("value", 0),
        "is_even": False,
        "is_odd": False,
        "is_prime": False,
        "route": None,
        "output": None
    }

def route_validator(state: State):
    retval = state["route"]

    return retval

def is_even(state: State):
    if state["value"] % 2 == 0:
        state["is_even"] = True
        state["route"] = "it_is_even"
    else:
        state["is_even"] = False
        state["route"] = "it_is_not_even"
    
    return state

def is_odd(state: State):
    if state["value"] % 2 == 0:
        state["is_odd"] = False
    else:
        state["is_odd"] = True
    
    return state

def is_prime(state: State):
    n = state["value"]
    state["is_prime"] = is_n_prime(n)

    return state

def build_output(state: State):
    if state['is_prime']:
        tstr = f"{state['value']} is Even number"
    else:
        tstr = f"{state['value']} is Odd number"

    if state["is_prime"]:
        tstr += " and Prime"
    else:
        tstr += " and Not a Prime"
        
    state["output"] = tstr
    return state
    
def build_graph():
    builder = StateGraph(State)
    
    builder.add_node("INITIALIZER", initialize_state_defaults)
    builder.add_node("EVEN_NUM", is_even)
    builder.add_node("ODD_NUM", is_odd)
    builder.add_node("PRIME_NUM", is_prime)
    builder.add_node("OUTPUT", build_output)
    
    builder.add_edge(START, "INITIALIZER")
    builder.add_edge("INITIALIZER", "EVEN_NUM")
    builder.add_conditional_edges(
        "EVEN_NUM", 
        route_validator, {
            "it_is_even": "OUTPUT",
            "it_is_not_even": "ODD_NUM"
        }
    )
    builder.add_edge("ODD_NUM", "PRIME_NUM")
    builder.add_edge("PRIME_NUM", "OUTPUT")
    builder.add_edge("OUTPUT", END)

    graph = builder.compile()

    save_graph_as_png(graph, __file__)

    return graph


graph = build_graph()
    

def main():
    response = graph.invoke({"value": 10})
    print(f"Response :{response['output']}")
    print()
    
    response = graph.invoke({"value": 17})
    print(f"Response :{response['output']}")
    print()

if __name__ == "__main__":
    main()



# lg_utility.py
import os

def save_graph_as_png(graph, filename=None):
    if filename is None:
        filename = os.path.splitext(os.path.basename(__file__))[0]
    
    png_bytes = graph.get_graph().draw_mermaid_png()
    with open(f"{filename}.png", "wb") as f:
        f.write(png_bytes)